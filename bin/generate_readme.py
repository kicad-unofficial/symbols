#!/usr/bin/env python3
import functools
import os
import re
from bin.utils.common.kicad_sym import KicadSymbol
from utils.common.kicad_sym import KicadLibrary
import sys

files = sorted(sys.argv[1:], key=str.casefold)


def symbol_cmp(a: KicadSymbol, b: KicadSymbol) -> int:
    if is_enclosure(a) and is_enclosure(b):
        # Sort enclosures by description (and therefore size)
        a = a.get_property("ki_description").value.lower()
        b = b.get_property("ki_description").value.lower()
    else:
        a = a.name.lower()
        b = b.name.lower()

    if a.startswith(b):
        return +1
    if b.startswith(a):
        return -1

    return (a > b) - (a < b)


def footprint_markdown(sym: KicadSymbol) -> str:
    if "enclosure" in sym.get_property("ki_description").value.lower():
        return ""

    fp = sym.get_property("Footprint").value
    if not fp.startswith("Vendor_"):
        return ""

    lib, fp = fp.split(":")
    lib = lib.removeprefix("Vendor_")
    fp = fp.removeprefix(lib)
    fp = fp.replace("_", " ")
    fp = fp.strip(", ")

    anchor = f"user-content-{lib}_{fp}".lower()

    return f"[ðŸ‘£](https://github.com/kicad-unofficial/footprints#{anchor} 'Footprint: {lib} {fp}')"


def description(sym: KicadSymbol) -> str:
    desc = sym.get_property("ki_description").value
    desc = desc.replace("automotive qualified", "")
    desc = desc.replace("enclosure", "")
    desc = desc.replace("flame retardant", "")

    def rep(m: re.Match):
        return m.group(0).replace("x", "Ã—")

    desc = re.sub("([0-9]+x)+[0-9]+mm", rep, desc)

    while ", , " in desc:
        desc = desc.replace(", , ", ", ")

    desc = desc.strip(", ")
    desc = desc.replace(", ", " â€¢ ")

    return desc


def child_description(parent: KicadSymbol, child: KicadSymbol) -> str:
    p = description(parent)
    c = description(child)

    c = c.replace(parent.name, "")
    c = c.replace(p, "")
    c = c.removeprefix(parent.name)
    c = c.strip(",â€¢ ")

    return c


def is_automotive(sym: KicadSymbol) -> bool:
    kw = sym.get_property("ki_keywords")
    if not kw:
        return False

    return "automotive" in kw.value.lower().split(" ")


def is_enclosure(sym: KicadSymbol) -> bool:
    kw = sym.get_property("ki_keywords")
    if not kw:
        return False

    return "enclosure" in kw.value.lower().split(" ")


def is_flame_retardant(sum: KicadSymbol) -> bool:
    desc = sym.get_property("ki_description")
    return "flame retardant" in desc.value.lower()


print('''
<!-- THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT! -->

# Symbol Libraries

An unofficial collection of schematic symbols for KiCad 6.

## Atomic Parts

All parts are "atomic" &mdash; they have a "fully-specified" symbol and an
associated footprint. The footprints are created directly from the
manufacturer's specifications and are located in the
[kicad-unofficial/footprints] repository.

Because the symbols are fully-specified, they each represent a specific part
that can be ordered from a supplier. Furthermore, they work out-of-the-box with
the [Octopart BOM generator]. An `Octopart Query` field is included where
necessary.

Generic symbols are also provided for parts that are available in more than one
package, but no generic symbol is provided without accompanying fully-specified
symbols.

For more information about "atomic" parts, "fully-specified" symbols and
"generic" symbols, please see the [KiCad Library Conventions].

## Automotive Qualified Parts

Automotive qualified parts (AEC-Q100, etc) are marked with a ðŸš— (car icon) in
the [symbol index] below.

The keyword `automotive` can be used to find these symbols within KiCad.

## Enclosures

Some symbols represent PCB enclosures rather than parts to be placed on the PCB.
They are marked with a ðŸ“¦ (package icon) in the [symbol index] below.

Enclosure footprints define the edge cuts layer (PCB shape) and mounting holes.


## Symbol Index

This is an index of the available libraries and the symbols they contain. Each
library contains symbols for a specific vendor or manufacturer.
''')

for file in files:
    name, _ = os.path.splitext(os.path.basename(file).removeprefix('Vendor_'))
    print(f"- [{name}](#{name.lower()})")

print()

for file in files:
    name, _ = os.path.splitext(os.path.basename(file).removeprefix('Vendor_'))
    lib = KicadLibrary.from_file(file)

    print(f"### {name}")
    print()

    symbols = lib.symbols
    symbols.sort(key=functools.cmp_to_key(symbol_cmp))

    for sym in lib.symbols:
        if sym.extends:
            continue

        url = sym.get_property("Datasheet").value
        fp = footprint_markdown(sym)

        item = f"- [{sym.name}]({url}) "

        if is_automotive(sym):
            item += "[ðŸš—](#automotive-qualified-parts 'Automotive Qualified Part') "

        if is_enclosure(sym):
            item += "[ðŸ“¦](#enclosures 'PCB Enclosure') "

            if is_flame_retardant(sym):
                item += "[ðŸ”¥](#enclosures 'Flame Retardant') "

        item += f"&mdash; {description(sym)}"

        if fp:
            item += f" {fp}"

        print(item)

        for child in lib.symbols:
            if child.extends == sym.name:
                child_url = child.get_property("Datasheet").value
                child_fp = footprint_markdown(child)

                item = f"  - [{child.name}]({child_url}) "

                if not is_automotive(sym) and is_automotive(child):
                    item += "[ðŸš—](#automotive-qualified-parts 'Automotive Qualified Part') "

                item += f"&mdash; {child_description(sym, child)}"

                if child_fp != fp:
                    item += f" {child_fp}"

                print(item)

    print()

print("""## Notes for Symbol Creators

- Name the component as the part number used for ordering, excluding packing alternatives.
- Start the description with the "general" part number (usually the one used to identify the datasheet).
- Prefer symbols that are easy to layout in schematics over symbols that match pin layouts.
- End the description with the package name, if multiple are available.
- Use a border of `0.254mm` on filled shapes
- Link directly to manufacturer's datasheet (not Mouser, for example)
- Include an [`Octopart Query` field](https://github.com/kicad-unofficial/bom/tree/main/octopart#readme), wherever possible
- For automotive qualified parts:
  - Include `automotive` and `aec` keywords
  - Include `automotive qualified` in the description

<!-- references -->

[kicad library conventions]: https://klc.kicad.org/general/g2/g2.1/

[octopart bom generator]:
https://github.com/kicad-unofficial/bom/tree/main/octopart#readme

[kicad-unofficial/footprints]: https://github.com/kicad-unofficial/footprints

[symbol index]: #symbol-index
""")
